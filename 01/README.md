# Module 01 - C++ Memory Allocation and Pointers

Module 01 of the C++ course delved into the intricacies of memory allocation, pointers, references, and the switch statement. This module built upon the foundational knowledge from Module 00 and allowed me to explore more advanced C++ concepts.

## Learning Outcomes
Throughout Module 01, I accomplished the following learning outcomes:

- Mastered memory allocation in C++, understanding the differences between stack and heap memory and when to use each appropriately.
- Explored pointers and their significance in managing memory and accessing data indirectly.
- Understood references and their benefits in creating alias names for variables, making code more concise and readable.
- Utilized the switch statement as a powerful control flow construct for handling multiple conditions efficiently.
- Learned to design classes with dynamic memory allocation, optimizing resource management and avoiding memory leaks.
- Implemented various C++ classes and member functions, applying object-oriented programming principles effectively.
- Successfully worked with C++ strings and used them wisely to manipulate text.

## Key Concepts Covered
Module 01 covered the following key concepts:

- Memory allocation (stack vs. heap)
- Pointers and pointer arithmetic
- References and their usage
- The switch statement for control flow
- Dynamic memory management with classes
- Working with C++ strings

## Reflection
Module 01 was an exciting and challenging learning experience that expanded my understanding of C++ programming. It reinforced the importance of memory management, particularly in the context of pointers and dynamic memory allocation. I found pointers to be both powerful and delicate, requiring careful attention to avoid common pitfalls like memory leaks and dangling pointers.

The introduction to references was a game-changer, offering an elegant alternative to pointers for certain scenarios. The switch statement provided a clean and efficient way to handle multiple conditions, making my code more organized and easier to maintain.

As I worked through exercises like "BraiiiiiiinnnzzzZ," "Unnecessary violence," and "Harl filter," I practiced implementing classes, member functions, and pointer-to-member functions. These exercises tested my ability to think critically and design efficient solutions to real-world problems.

Module 01 reinforced the significance of robust coding practices, effective memory management, and adherence to best practices in C++ development. I feel more confident in handling memory allocation and have a deeper appreciation for the language's flexibility and power.

I'm eager to move on to Module 02 and continue building upon the foundation laid in Module 01. With each new module, I gain more skills and insights into the world of C++ programming, and I look forward to the challenges and growth that lie ahead.
